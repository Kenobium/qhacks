## Inspiration
The concept of superposition might seem abstract to those unfamiliar with quantum computing. What does it mean for a qubit to be in "multiple states at once"? And what's the point of a superposition if it collapses as soon as we try to measure it? This app helps the user grasp the idea of a superposition with an interactive demonstration of the qubit's probabilistic nature.

## What it does
The user first chooses the number of states that can be represented by our quantum system. An interface is shown, allowing them to set a probability for each possible state up to the maximum value. The user can also choose to set an equal probability distribution. When run, the backend creates the requested superposition and samples it a certain number of times (another parameter set by the user), as the main principle of quantum computing is its probabilistic nature. Some statistics are shown, including the number of qubits used to represent the states and the normalized ket representation of the superposition. Finally, the results of the measurement are displayed as key-value pairs for each state and the fraction of samples in which it was measured.

## How we built it
The application runs the IBM Qiskit library on a Python backend script. This script is similar in function to Qiskit's `initialize()` method, but uses a custom implementation that takes the desired probabilities as inputs, constructs a unitary matrix transformation using the Gram-Schmidt process, and outputs the results of the simulated quantum circuit. The frontend is built using the **Next.js** framework and interfaces with the Python backend via the `python-shell` module. For styling we used **tailwind** and a component library called **daisy-ui**.

## Challenges we ran into
Our initial direction for this hackathon was to write a working implementation of Shor's algorithm as a means to crack low-grade RSA encryption, such as 128- and 256-bit RSA. We had hoped to demonstrate a quantum advantage in this use case over brute-force and numerical methods for classical computers. However, we realized too late that our current quantum computers (and simulators) do not have the resources to factor numbers larger than 21 using Shor's algorithm. At this point, we decided to pivot. We decided to work on more of an educational tool but creating a dynamically generated quantum circuit that could have any number of states, each with unique probabilities was a challenge too but with some research we were able to figure out the algorithm. We also had some difficulty in linking our Python backend to our JavaScript frontend, but the `python-shell` module made this relatively straightforward.

## What we learned
Through this project, we learned some of the basics of quantum computing and the Qiskit library. Developing for quantum certainly requires a significant shift from the way we usually approach programming. We were proud of our custom implementation for qubit state preparation as it gave us the opportunity to apply linear algebra and led us to think mathematically about the quantum system. We also learned how to run our Python script directly from the JavaScript web app, which we didn't really know we could do.

## What's next for Quantum State Simulator
Given more time, we would like to add visualizations to our application, such as a histogram and a Bloch sphere. Ideally, we would also make some UI changes to improve the application flow and make individual probabilities easier to change. Once quantum computers evolve further, we would also like to return to our original Shor's algorithm idea so we can hack people.
